#pragma once

#include "constraint.h"
#include "location.h"
#include "execution.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Instruction.h"
#include "fmt/format.h"
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <stack>

class AnalysisContext;
class AbstractExecution;

/**
 * Summary information generated by analysis
 */
struct FunctionSummary
{
    const llvm::Function* function;

    std::vector<const llvm::GlobalVariable*> globals;

    std::vector<const llvm::Value*> inputs;

    const llvm::Value* return_val;

    std::shared_ptr<const AbstractExecution> result;

    std::shared_ptr<SmtProvider> smt_engine;
};

/**
 * Global environment of analysis. It stores existing summary and SMT provider.
 */
class SummaryEnvironment
{
private:
    std::shared_ptr<SmtProvider> smt_engine = std::make_shared<SmtProvider>();
    std::unordered_map<const llvm::Function*, std::unique_ptr<FunctionSummary>> analysis_cache;

public:
    const auto& SmtEngine() const noexcept { return smt_engine; }

    bool IsAnalyzed(const llvm::Function* func) const
    {
        return analysis_cache.find(func) != analysis_cache.end();
    }

    const FunctionSummary& LookupSummary(const llvm::Function* func) const
    {
        return *analysis_cache.at(func);
    }

    void RegisterSummary(const llvm::Function* func, std::unique_ptr<FunctionSummary> summary)
    {
        analysis_cache.insert(std::pair{func, std::move(summary)});
    }

    void Analyze(const llvm::Function* fun);
};

// (source, target)
using ControlFlowEdge = std::pair<const llvm::BasicBlock*, const llvm::BasicBlock*>;

struct IndexedInputValue
{
    int index;
    const llvm::Value* value;
};

/**
 *  Context in which a function is analyzed. Note a function should only be
 * analyzed after all its called function.
 */
class AnalysisContext
{
private:
    const SummaryEnvironment* env_;

    const llvm::Function* func_;

    std::vector<const llvm::Function*> called_functions_;

    std::vector<const llvm::GlobalVariable*> globals_;

    std::vector<const llvm::Value*> inputs_;

    // value that the function returns
    const llvm::Value* return_val_;

    // cached backward edges for analysis
    std::set<ControlFlowEdge> backedges_;

    // values locations of which may alias
    // TODO: may consider add multiple alias group for a more precise
    // analysis
    std::vector<IndexedInputValue> alias_group_;

    ConstraintSolver smt_solver_;

    std::unordered_map<const llvm::Instruction*, int> call_point_cache_;

    // computed consequent heaps
    std::unordered_map<const llvm::BasicBlock*, std::shared_ptr<AbstractExecution>> exec_results_;

public:
    AnalysisContext(const SummaryEnvironment* env, const llvm::Function* func);

    int GetCallPoint(const llvm::Instruction* inst);

    // creates an new execution state which represents the start of the
    // specified basic block
    std::shared_ptr<AbstractExecution> InitializeExecution(const llvm::BasicBlock* bb);

    // returns a finished execution state that represents end of specified
    // basic block, if any
    std::shared_ptr<AbstractExecution> RetrieveExecution(const llvm::BasicBlock* bb);

    // try to update the execution result if program state of `new_exec`
    // differs from the previous run returns true if the state is updated
    bool UpdateExecution(const llvm::BasicBlock* bb, std::shared_ptr<AbstractExecution> new_exec);

    // generate summary from a finished context
    // Note the context is invalidated after this function is called
    std::unique_ptr<FunctionSummary> YieldSummary();

    const SummaryEnvironment& Environment() const noexcept { return *env_; }

    const llvm::Function* GetFunction() const noexcept { return func_; }

    const auto& GetCalledFunctions() const noexcept { return called_functions_; }

    const auto& GetInputs() const noexcept { return inputs_; }

    const llvm::Value* GetReturnValue() const noexcept { return return_val_; }

    auto& GetSmtSolver() noexcept { return smt_solver_; }

private:
    AbstractStore CreateBootstrapStore();
};

std::unique_ptr<FunctionSummary>
AnalyzeFunction(const SummaryEnvironment& env,
                const std::unordered_set<const llvm::Function*>& call_history,
                const llvm::Function* func);