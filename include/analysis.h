#pragma once

#include "constraint.h"
#include "location.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Instruction.h"
#include "fmt/format.h"
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <stack>

class AnalysisContext;
class AbstractExecution;

/**
 * Summary information generated by analysis
*/
struct FunctionSummary
{
    const llvm::Function* function;

    std::vector<const llvm::Value*> inputs;

    const llvm::Value* output;

    std::shared_ptr<AbstractExecution> result;

    std::shared_ptr<SmtProvider> smt_engine;
};

/**
 * Global environment of analysis. It stores existing summary and SMT provider.
*/
class SummaryEnvironment
{
public:
    std::shared_ptr<SmtProvider> smt_engine = std::make_shared<SmtProvider>();
    std::unordered_map<const llvm::Function*, std::unique_ptr<FunctionSummary>> analysis_cache;

    bool IsAnalyzed(const llvm::Function* fun) const
    {
        return analysis_cache.find(fun) != analysis_cache.end();
    }

    void RegisterSummary(const llvm::Function* func, std::unique_ptr<FunctionSummary> summary);

    void Analyze(const llvm::Function* fun);
};

// (source, target) pair
using ControlFlowEdge = std::pair<const llvm::BasicBlock*, const llvm::BasicBlock*>;

/**
 *  Context in which a function is analyzed. Note a function should only be analyzed after all its called function.
 */
class AnalysisContext
{
private:
    const SummaryEnvironment* env;

    const llvm::Function* func;

    // contains either llvm::Argument or llvm::GlobalVariable
    std::vector<const llvm::Value*> inputs;

    std::vector<const llvm::Argument*> parameters;

    std::vector<const llvm::GlobalVariable*> globals;

    // values locations of which may alias
    // TODO: may consider add multiple alias group for a more precise analysis
    std::vector<const Value*> alias_group;

    // value that the function returns
    const llvm::Value* output;

    // cached backward edges for analysis
    std::set<ControlFlowEdge> backedges;

    // computed consequent heaps
    std::unordered_map<const llvm::BasicBlock*, std::shared_ptr<AbstractExecution>> exec_results;

    ConstraintSolver smt_solver_;

public:
    AnalysisContext(const SummaryEnvironment* env, const llvm::Function* func);
    AnalysisContext(const std::shared_ptr<SmtProvider>& smt_engine, const llvm::Function* func);

    // creates an new execution state which represents the start of the specified basic block
    std::shared_ptr<AbstractExecution> InitializeExecution(const llvm::BasicBlock* bb);

    // returns a finished execution state that represents end of specified basic block, if any
    std::shared_ptr<AbstractExecution> RetrieveExecution(const llvm::BasicBlock* bb);

    // try to update the execution result if program state of `new_exec` differs from the previous run
    // returns true if the state is updated
    bool UpdateExecution(const llvm::BasicBlock* bb, std::shared_ptr<AbstractExecution> new_exec);

    std::unique_ptr<FunctionSummary> YieldSummary();

    const llvm::Function* GetFunction() const noexcept
    {
        return func;
    }

    std::vector<const llvm::Value*> GetInputs() const noexcept
    {
        return inputs;
    }

    const llvm::Value* GetOutput() const noexcept
    {
        return output;
    }

    auto& GetSmtSolver() noexcept
    {
        return smt_solver_;
    }

private:
};

std::unique_ptr<FunctionSummary> AnalyzeFunction(const SummaryEnvironment& env, std::stack<const Function*>& call_chain, const Function* func);